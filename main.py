from paddlenlp import Taskflowfrom flask import abort, Flask, jsonify, requestfrom flask_healthz import healthzfrom cleantext import cleanfrom pprint import pprintapp = Flask(__name__)app.register_blueprint(healthz, url_prefix="/healthz")def liveness():    passdef readiness():    passapp.config.update(    HEALTHZ = {        "live": app.name + ".liveness",        "ready": app.name + ".readiness"    })def preprocess_text(text):    if isinstance(text, str):        return clean(text, fix_unicode=True, to_ascii=True, lower=False, no_line_breaks=True, no_urls=True, no_emails=True, lang="en")    elif isinstance(text, list):        return [clean(t, fix_unicode=True, to_ascii=True, lower=False, no_line_breaks=True, no_urls=True, no_emails=True, lang="en") for t in text]    else:        raise TypeError("Input message must be of type str or list.")def load_model(scheme, model: str = "utc"):    if model == "utc":        return Taskflow("zero_shot_text_classification", schema=scheme)    else:        raise NotImplementedError("Currently only utc is integrated.")default_scheme = ["Earthquake", "Flooding", "Tropical storm", "Explosion", "Shooting", "Wildfire", "Hostage",                  "Pandemic", "War", "Inflation"]model = load_model(scheme=default_scheme, model="utc")@app.route('/', methods=['POST'])def flask():    responses = {'error': 'undefined'}    http_code = 418    authenticated = False    if 'key' in request.json:        key = request.json['key']        if (key == 'GBGBE3THWLF9FB2U'): authenticated = True    if (authenticated == False):        responses = {'error': 'no valid API key'}        http_code = 401    if not request.json or not 'message' in request.json:        abort(400)    elif 'message' in request.json:        if "scheme" in request.json:            scheme = request.json['scheme']            model.set_schema(scheme)        message = request.json['message']        clean_text = preprocess_text(message)        predictions = model(clean_text)        responses = []        for i, prediction in enumerate(predictions):            if not prediction["predictions"]:                if isinstance(message, str):                    return_message = message                elif isinstance(message, list):                    return_message = message[i]                else:                    raise TypeError("Input text must be of type str or list.")                response = {'message': return_message, 'label': ["out-of-scope"], "confidence_score": [0]}            else:                response = {'message': prediction["text_a"], 'label': [p["label"] for p in prediction["predictions"]],                            "confidence_score": [p["score"] for p in prediction["predictions"]]}            responses.append(response)    else:        responses = {'error': 'no valid input'}        http_code = 400    return jsonify(responses), http_codeif __name__ == "__main__":    app.run(host='0.0.0.0')    # scheme = ["environmental events", "societal events", "governmental events", "natural disaster"]    # model.set_schema(scheme)    #    # message = ["A preliminary 6.20 magnitude #earthquake has occurred near Taft, Eastern Visayas, #Philippines.",    #         "A shooting has been reported at Saugus High School in Santa Clarita just north of Los Angeles.",    #         "One person was missing following a large explosion at an apparent industrial building in Houston Friday. The blast damaged nearby buildings and homes.",    #         "Gunman murdered travelers in Hamburg train station last night.",    #         "It is so hot that I feel the earth is shaking"]    # message="Gunman murdered travelers in Hamburg train station last night."    # clean_text = preprocess_text(message)    # predictions = model(clean_text)    #    # responses = []    # for i, prediction in enumerate(predictions):    #     if not prediction["predictions"]:    #         if isinstance(message, str):    #             return_message = message    #         elif isinstance(message, list):    #             return_message = message[i]    #         else:    #             raise TypeError("Input text must be of type str or list.")    #         response = {'message': return_message, 'label': ["out-of-scope"], "confidence_score": [0]}    #     else:    #         response = {'message': prediction["text_a"], 'label': [p["label"] for p in prediction["predictions"]], "confidence_score": [p["score"] for p in prediction["predictions"]]}    #     responses.append(response)    # pprint(responses)